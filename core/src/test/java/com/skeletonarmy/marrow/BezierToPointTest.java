package com.skeletonarmy.marrow;

import com.skeletonarmy.marrow.bezierGeneration.BezierToPoint;
import com.skeletonarmy.marrow.bezierGeneration.CircleObstacle;
import com.skeletonarmy.marrow.bezierGeneration.Obstacle;
import com.skeletonarmy.marrow.bezierGeneration.Point;
import com.skeletonarmy.marrow.bezierGeneration.PolygonObstacle;
import com.skeletonarmy.marrow.bezierGeneration.Pose;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class BezierToPointTest {
    private static final double ROBOT_WIDTH = 18.0;
    private static final double ROBOT_HEIGHT = 18.0;

    @BeforeEach
    void setUp() {
        // Clear obstacles for each test to ensure isolation
        BezierToPoint.initialize(ROBOT_WIDTH, ROBOT_HEIGHT);
    }

    // Test Case: Simple Path (No Obstacles)

    @Test
    void shouldGenerateMidpointForSimplePath() {
        // Arrange
        Pose startPose = new Pose(10, 10, 0); // Heading is 0 radians
        Pose endPose = new Pose(50, 50, 0);   // Heading is 0 radians

        // Act
        Point midPoint = BezierToPoint.generateMidPoint(startPose, endPose);

        // Assert
        assertNotNull(midPoint);
        double expectedMidX = (10 + 50) / 2.0;
        double expectedMidY = (10 + 50) / 2.0;

        // Print the results for this test
        System.out.println("--- Test: Simple Path ---");
        System.out.println("Expected Midpoint: (" + expectedMidX + ", " + expectedMidY + ")");
        System.out.println("Generated Midpoint: (" + midPoint.x + ", " + midPoint.y + ")");
        System.out.println("Is within tolerance? " + (Math.abs(midPoint.x - expectedMidX) < 0.01 && Math.abs(midPoint.y - expectedMidY) < 0.01));

        assertTrue(Math.abs(midPoint.x - expectedMidX) < 0.01);
        assertTrue(Math.abs(midPoint.y - expectedMidY) < 0.01);
    }

    // Test Case: Path Blocked by Circle Obstacle

    @Test
    void shouldGenerateOffsetMidpointWhenPathIsBlockedByCircle() {
        // Arrange
        Obstacle circle = new CircleObstacle(new Point(30, 30), 5);
        BezierToPoint.initialize(ROBOT_WIDTH, ROBOT_HEIGHT, circle);

        Pose startPose = new Pose(10, 10, 0);
        Pose endPose = new Pose(50, 50, 0);

        // Act
        Point midPoint = BezierToPoint.generateMidPoint(startPose, endPose);

        // Assert
        assertNotNull(midPoint);

        // Print the results for this test
        System.out.println("\n--- Test: Path Blocked by Circle ---");
        System.out.println("Obstacle: Circle at (30, 30) with radius 5");
        System.out.println("Generated Midpoint: (" + midPoint.x + ", " + midPoint.y + ")");

        // Check and print if the midpoint is offset
        double expectedMidX = (10 + 50) / 2.0;
        double expectedMidY = (10 + 50) / 2.0;
        boolean isOffset = Math.abs(midPoint.x - expectedMidX) > 1.0 || Math.abs(midPoint.y - expectedMidY) > 1.0;
        System.out.println("Is Midpoint Offset? " + isOffset);
        assertTrue(isOffset, "Midpoint should be offset from the straight path.");

        // A stronger assertion: The path generated by the new midpoint must be collision-free.
        Point[] controlPoints = {
                new Point(startPose.getPosition().x, startPose.getPosition().y),
                midPoint,
                new Point(endPose.getPosition().x, endPose.getPosition().y)
        };
        boolean pathIsClear = isBezierPathClear(controlPoints, Arrays.asList(circle));
        System.out.println("Is generated path clear of obstacles? " + pathIsClear);
        assertTrue(pathIsClear, "The generated path should not collide with the obstacle.");
    }

    // Test Case: Path Blocked by Polygon Obstacle

    @Test
    void shouldGenerateOffsetMidpointWhenPathIsBlockedByPolygon() {
        // Arrange
        Point[] corners = {
                new Point(25, 25),
                new Point(35, 25),
                new Point(35, 35),
                new Point(25, 35)
        };
        Obstacle square = new PolygonObstacle(corners);
        BezierToPoint.initialize(ROBOT_WIDTH, ROBOT_HEIGHT, square);

        Pose startPose = new Pose(10, 10, 0);
        Pose endPose = new Pose(50, 50, 0);

        // Act
        Point midPoint = BezierToPoint.generateMidPoint(startPose, endPose);

        // Assert
        assertNotNull(midPoint);

        // Print the results for this test
        System.out.println("\n--- Test: Path Blocked by Polygon ---");
        System.out.println("Obstacle: Square from (25, 25) to (35, 35)");
        System.out.println("Generated Midpoint: (" + midPoint.x + ", " + midPoint.y + ")");

        double expectedMidX = (10 + 50) / 2.0;
        double expectedMidY = (10 + 50) / 2.0;
        boolean isOffset = Math.abs(midPoint.x - expectedMidX) > 1.0 || Math.abs(midPoint.y - expectedMidY) > 1.0;
        System.out.println("Is Midpoint Offset? " + isOffset);
        assertTrue(isOffset, "Midpoint should be offset from the straight path.");

        Point[] controlPoints = {
                new Point(startPose.getPosition().x, startPose.getPosition().y),
                midPoint,
                new Point(endPose.getPosition().x, endPose.getPosition().y)
        };
        boolean pathIsClear = isBezierPathClear(controlPoints, Arrays.asList(square));
        System.out.println("Is generated path clear of obstacles? " + pathIsClear);
        assertTrue(pathIsClear, "The generated path should not collide with the obstacle.");
    }

    // Helper Methods (unchanged)
    private boolean isBezierPathClear(Point[] controlPoints, List<Obstacle> obstacles) {
        // ... (body of the method remains the same)
        List<Point> curve = generateCurvePoints(controlPoints, 100);

        for (Point point : curve) {
            if (isOverlappingAnyObstacle(point, obstacles)) {
                return false;
            }
        }
        return true;
    }

    private List<Point> generateCurvePoints(Point[] controlPoints, int numPoints) {
        // ... (body of the method remains the same)
        List<Point> curve = new ArrayList<>();
        int n = controlPoints.length - 1;
        for (int i = 0; i < numPoints; i++) {
            double t = i / (double)(numPoints - 1);
            Point result = new Point(0, 0);
            for (int j = 0; j <= n; j++) {
                double binomial = binomialCoeff(n, j);
                double coeff = binomial * Math.pow(t, j) * Math.pow(1 - t, n - j);
                result.x += coeff * controlPoints[j].x;
                result.y += coeff * controlPoints[j].y;
            }
            curve.add(result);
        }
        return curve;
    }

    private double binomialCoeff(int n, int k) {
        // ... (body of the method remains the same)
        double res = 1;
        for (int i = 0; i < k; ++i) {
            res *= (n - i);
            res /= (i + 1);
        }
        return res;
    }

    private boolean isOverlappingAnyObstacle(Point point, List<Obstacle> obstacles) {
        // ... (body of the method remains the same)
        double halfWidth = ROBOT_WIDTH / 2.0;
        double halfHeight = ROBOT_HEIGHT / 2.0;
        Point[] robotCorners = new Point[]{
                new Point(point.x - halfWidth, point.y - halfHeight),
                new Point(point.x + halfWidth, point.y - halfHeight),
                new Point(point.x + halfWidth, point.y + halfHeight),
                new Point(point.x - halfWidth, point.y + halfHeight)
        };

        for (Obstacle obs : obstacles) {
            if (obs instanceof PolygonObstacle) {
                for (Point corner : robotCorners) {
                    if (((PolygonObstacle) obs).isOverlapping(corner)) {
                        return true;
                    }
                }
            } else if (obs instanceof CircleObstacle) {
                for (Point corner : robotCorners) {
                    if (((CircleObstacle) obs).isOverlapping(corner)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}